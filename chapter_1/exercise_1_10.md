## P24 - [练习 1.10]

使用下面代码打印结果。

``` Scheme
#lang racket

(define (A x y)
  (cond ((= y 0) 0)
        ((= x 0) (* 2 y))
        ((= y 1) 2)
        (else (A (- x 1)
                 (A x (- y 1))))))

(A 1 10)
(A 2 4)
(A 3 3)
```

可知道 

```
(A 1 10) = 1024
(A 2 4) = 65536
(A 3 3) = 65536
```

---------

也可以手动展开计算过程。

``` Scheme
(A 1 10)
(A 0 (A 1 9))
(* 2 (A 1 9))
(* 2 (A 0 (A 1 8))
(* 2 (* 2 (A 1 8))
(* 2 (* 2 (A 0 (A 1, 7))
(* 2 (* 2 (* 2 (A 1, 7))
....
(* 2 (* 2 (* 2 (* 2 ....(* 2 (A 1 1))))))))))
(* 2 (* 2 (* 2 (* 2 ....(* 2 2)))))))       ;; 10 个 2 连续相乘
....
1024
```

从 `(A 1 10)` 的展开过程可以看出 (A 1 n) 的结果为 n 个 2 相乘，也就是 2 的 n 次方 `(expt 2 n)`

``` Scheme
(A 2 4)
(A 1 (A 2 3))
(A 1 (A 1 (A 1 2)))
;; 接下来不再逐步展开，直接使用结论 (A 1 n) = (expt 2 n)
...
(A 1 (A 1 4))
(A 1 16)
65536
```

从 `(A 2 4)` 的展开过程可以看出 (A 2 n) 的结果为连续求 n 次二次幂。也就是 `(expt 2 (expt 2 (expt 2 1)))`，也就是

``` Scheme
(A 2 1) = (expt 2 1) = 2
(A 2 2) = (expt 2 (A 2 1)) = (expt 2 2) = 4
(A 2 3) = (expt 2 (A 2 2)) = (expt 2 4) = 16
(A 2 4) = (expt 2 (A 2 3)) = (expt 2 16) = 65536
(A 2 5) = (expt 2 (A 2 4)) = (expt 2 65536) = 超级大的数字
```

``` Scheme
(A 3 3)
(A 2 (A 3 2))
(A 2 (A 2 (A 3 1)))
(A 2 (A 2 2))
;; 接下来直接应用 (A 2 n) 的展开结果，为
(A 2 4)
65536
```

---------

可以使用程序打印出前面几个值，总结出公式。或者手动展开分析。

* (A 0 n) 展开为 (* 2 n)，数学公式为 2 * n
* (A 1 n) 在上面已经说了，是 2 的 n 次方 `(expt 2 n)`。数学公式为 `2 ^ n`。
* (A 2 n) 在上面也已经说了，连续求 n 次二次幂。数学公式是 `2 ^ (2 ^ (2 ^ ... (2 ^ 2)))` 有 n 次。

使用程序打印出数值，做成表格

 n       | 0  | 1  | 2  | 3   | 4     | 5   | 6   | 7   | 8   | ... |
---------|----|----|----|-----|-------|-----|-----|-----|-----|-----|
 (A 0 n) | 0  | 2  | 4  | 6   | 8     | 10  | 12  | 14  | 16  | ... |
 (A 1 n) | 0  | 2  | 4  | 8   | 16    | 32  | 64  | 128 | 256 | ... |
 (A 2 n) | 0  | 2  | 4  | 16  | 65536 | ... | ... | ... | ... | ... |


---------

也可以根据数学归纳法推导出公式：

``` Scheme
(f n) ->
(A 0 n) ->
(* 2 n)
;; 可见 (f n) 即为 2n
```

``` Scheme
(g n) ->
(A 1 n) ->
(A 0 (A 1 (- n 1))) ->
(f (A 1 (- n 1))) ->
(f (g (- n 1))) ->
(* 2 (g (- n 1)))
;; 可见 g(n) = 2 * g(n - 1)
;; 并且 g(1) = 2
;; 通过归纳法可证明 (g n) 等于 2 ^ n
```

``` Scheme
(h n) ->
(A 2 n)
(A 1 (A 2 (- n 1))) ->
(g (A 2 (- n 1))) ->
(g (h (- n 1))) ->
(expt 2 (h (- n 1)))
;; 可见 h(n) = 2 ^ h(n - 1)
;; 并且 h(1) = 2
;; 通过归纳法可证明 (h n) 等于 2 ^ (2 ^ (2 ^ ... (2 ^ 2)))
```